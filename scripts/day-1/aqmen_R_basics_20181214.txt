# 
# AQMEN (Data Science for Social Research)
# http://www.aqmen.ac.uk/
# 
# Introduction to Data Science - An Introduction to Statistical Concepts for Data Analysis
# 
# 
# R Workshop (March 2019)
# 
# A two day hands-on workshop led by 
# Professor Vernon Gayle and Dr Diarmuid McDonnell, University of Edinburgh.
# 
# 
# ##############################################
# # IT IS IMPORTANT THAT YOU READ THIS HANDOUT #
# # AND FOLLOW THE R FILE LINE BY LINE! #
# ##############################################
# 
# 
# Topics: 
# 
# The course introduces participants to fundamental concepts in statistics, 
# rudimentary data analysis techniques and how to interpret results. 
# These skills are fundamental for the successful data analysis and data science.
# 
# Rationale: 
# 
# There are many organisations that increasingly require employees to understand 
# data, and to analyse data using statistical methods. 
# 
# Many employees do not have formal training in statistics. 
# 
# Some employees undertook classes at university, but for many people these 
# courses are now a distant memory. 
# 
# Understanding fundamental concepts in statistics, rudimentary data analysis 
# techniques, and how to interpret results are critical skills for the successful 
# analysis of data, which is at the core of data science.
# 
# Many organisations report that they have an absence of data analysis skills. 
# Other organisations report that some employees have skills but lack confidence
# in exercising them. The lack of skills and capacity is currently a major 
# obstacle to some organisations undertaking data analysis. 
# 
# This course will provide a fast-track introduction for employees wishing to 
# begin to analyse data in R.
# 
# Please be patient. Computers often go wrong.
# 
# Please asks the tutors for help.


##########################################################################################

##########################            R basics              ##############################

##########################################################################################

# R is a programming language. It has rules, packages, syntax, complexities, idiosyncracies...
# It is not particularly easy to learn, nevermind master. It can seem as if you have to learn everything in order
# to do anything!

# Persevere: like any language, once you grasp the building blocks you will begin to feel comfortable. All of the fancy models, code and graphs
# that make it into journal articles, textbooks, presentations etc are just extensions and flourishes added on top of the basic functions and rules.

# The important thing is to expect failure and react accordingly (just like an astronaut).

# Anyway, on with the show...

# -----------------------------------------------------------------------------------------

# This is a comment
## This is also a comment
###### ...you get the idea

# Comments are an important means of documenting your workflow and ensuring others (including future-you) can reproduce your work.

# In R studio, you can create multiline comments by highlighting the text and pressing "Ctr + Shift + c".

# If you run some code and nothing happens, check the console (bottom-left pane in RStudio): if you see a plus sign (+) then
# R thinks you haven't finished writing the command and expects more code. If this happens then press the ESC key to cancel the
# command.

# R is case sensitive e.g. 'View(data)' displays the data set in a window (similar to the 'browse' function in Stata);
# 'view(data)' does nothing.

############################################################

# Installing and Loading Packages #

# A package bundles together code, data, documentation, and tests 
# and provides an easy method to share with others.

# Installing packages
# install.packages("tidyverse") # data science collection of packages

# Loading packages
library(tidyverse)

############################################################

# Getting Help #

help.start() # provides general help links
help.search("regression") # searches the help system for documentation matching a given character string

help("strtrim") # finds help documentation on the "strtrim" function
?strtrim # another way of searching for help
example("strtrim") # display example code using this function
# In RStudio, you can also highlight the function in your code and press F1.

help(mean) # let's dissect the help material for the mean() function
vignette("dplyr") # some of the better-documented packages provide detailed examples of how to use the package

# Can't quite remember the name of an object or function?
apropos("sum") # returns all objects in the global environment that contain the text "sum"

# If you need help from the web then [insert chosen search engine] is your friend.
# Likewise, the Stackoverflow website is an excellent source of help on many programming languages and data wrangling/analysis problems.
# If you experience an error message then follow the above advice by searching for the exact message you receive i.e. don't paraphrase
# your issue.

############################################################


############################################################

# Keyboard Shortcuts #

# To execute R code: highlight the syntax and press Ctrl + Enter

# To execute the entire R script (i.e. all of the code in one): press Ctrl + Shift + S

# To insert the assignment operator (i.e '<-'): press Alt + minus key (-)

# To autocomplete your syntax: start typing the name of an object/function and press TAB

############################################################


############################################################

# Debugging #

# This is the computer science term for dealing with code issues. R likes to tell you when something is not quite right,
and not always in an intelligble manner. As progress with this workshop, you are likely to encounter the following results:
#	- message: R is communicating a diagnostic message relating to your code; your commands still execute.
#	- warning: R is highlighting an error/issue with your code, your commands still execute but the warnings need addressing.
#	- error: R is telling you there has been a fatal error with your code; your commands do not execute.

# Let's look at a simple example:
log(-1) # take the natural log of -1
# This warning tells you that the output is missing i.e. there is no natural log of a negative number.
warning() # displays the warnings associated with the most recently executed block of code

# You'll encounter plenty of messages, warnings and errors over the course of this workshop. For now, here is some general
# advice from Peng (2015) regarding what questions to ask when debugging:
#	- What was your input? How did you call the function?
#	- What were you expecting? Output, messages, other results?
#	- What did you get?
#	- How does what you get differ from what you were expecting?
#	- Were your expectations correct in the first place?
#	- Can you reproduce the problem (exactly)?

############################################################

# Data Types #

# The majority of material in this section is derived from Boehmke's book: Data Wrangling With R

# Variables are known as 'objects' in R and can store a wide variety of data types:
# - numeric
# - string
# - boolean etc

# Each data type can have different classes i.e. numeric has integer and double (e.g. decimal).

# Numeric
x <- 5 # Integer
y <- 5.5 # Double or Float
# Notice how RStudio doesn't print the value of x or y. To evaluate the assigment you need to call the object:
x
y
# Assign and evaluate in a single command:
(x <- 5)
# Our advice is to keep assingment and evaluation commands separate (those parentheses can add confusion and lead to errors) but the choice is your's...

print(x + y) # print ensures the result is displayed in the console or output window

# We can compare objects using a set of comparison operators:
x == y
x < y
x > y
x != y
x >= y
x <= y
# TASK: document what each of the comparison operators does.

print(typeof(x))
print(typeof(y)) # R stores numbers as a double; we need to be specific when assigning the object's value(s):

rm("x")
rm("y") # check the environment pane in the top-right hand corner of RStudio to see what objects remain in the global environment
x <- 5L
y <- 5.5
print(typeof(x)) # Now it is stored explicitly as an integer; in practice you often do not need to worry about this
print(typeof(y)) 
# Another approach is to convert an existing object:
int_var <- 20
as.integer(int_var)
print(typeof(int_var))

vec <- 1:10
print(vec) # creates a vector from 1 to 10
vec[1] # return the first element in vec
vec[1:5] return the first five elements in vec
# The above commands are known as 'slicing'

# sequence of numbers from a beginning to end in steps
sequence <- seq(from = 1, to = 100, by = 5)
print(sequence) 

# create a sequence based on repeating or replicating the numbers
repetition <- rep(1:10, each = 10)
print(repetition)

# Generating sequences of random numbers
# A useful function for performing simulations, creating objects or rows in a dataset etc

# generate 100 random numbers between 0 and 25 from a uniform distribution i.e. each number has an equal probability of being selected
runif(100, min = 0, max = 25)
# generate 100 random numbers between 0 and 25 (with replacement)
sample(0:25, 100, replace = TRUE)
# generate 100 random numbers between 0 and 25 (without replacement)
sample(0:25, 100, replace = FALSE)
# QUESTION: why can we not sample 100 numbers from this range without replacement?

# generate 1000 random numbers from a normal distribution with given mean & st. dev.
normdist <- rnorm(1000, mean = 0, sd = 1)
hist(normdist) # approximately normal 
print(summary(normdist))

# generate CDF probabilities for value(s) in vector q
pnorm(0.5, mean = 0, sd = 1)
# generate quantile for probabilities in vector p
qnorm(0.5, mean = 0, sd = 1)
# generate density function probabilites for value(s) in vector x
dnorm(0.5, mean = 0, sd = 1)

# generate a vector of length n displaying the number of successes from a trial
# size = 100 with a probabilty of success = 0.5
rbinom(10, size = 100, prob = 0.5)
# Question: how many successes were there in 10 trials, each with a sample size of 100?

# generate a vector of length n displaying the random number of events occuring
# when lambda (mean rate) equals 4.
rpois(20, lambda = 4)
# TASK: vary the number of expected events and interpret the results.

# We can reproduce random numbers by setting the seed:
set.seed(1) # name the random sample "1"
rsamp1 <- rnorm(n = 10, mean = 0, sd = 1)
set.seed(1)
rsamp2 <- rnorm(n = 10, mean = 0, sd = 1)
print(rsamp1)
print(rsamp2) # produces the same values in each random sample

# We can compare numbers using logical operators:
a <- 50
b <- 100
print(a > b)
print(a == b)
print(a < b) 
print(a != b) 
# returns "TRUE" or "FALSE"

x <- c(1, 4, 9, 12)
y <- c(4, 4, 9, 13)
x == y # compares each number in an array to its corresponding number in another array

# Note that logical values TRUE and FALSE equate to 1 and 0 respectively, allowing us to perform arithmetic operations using these results:
sum(x == y) # 2 instances where the numbers were equal

# To test if two objects are exactly equal:
identical(x, y)

# Rounding numbers
x <- c(1, 1.35, 1.7, 2.05, 2.4, 2.75, 3.1, 3.45, 3.8, 4.15, 4.5, 4.85, 5.2, 5.55, 5.9)
print(x)
# Round to the nearest integer
round(x) # note how the original object is not altered - run the command "print(x)"
# Round up
ceiling(x)
# Round down
floor(x)
# Round to a specified decimal
round(x, digits = 1)

# Dealing with Character Strings

a <- "learning to create" # create string a
b <- "character strings" # create string b
paste(a, b) # combine the strings
# paste character and number strings (converts numbers to character class)
paste("The life of", pi)
# paste multiple strings
paste("I", "love", "R")
# paste multiple strings with a separating character
paste("I", "love", "R", sep = "-")

# Converting to strings

a <- "The life of"
b <- pi
is.character(b) # check if b is a string
c <- as.character(b)
is.character(c)

# Printing strings

print(a)
print(a, quote = FALSE) # easier to use the command "noquote(a)"

cat(a)
cat(a, "Riley") # the cat function is useful for printing multiple objects in a readable format
cat(letters)

x <- "Today I am learning how to print strings."
y <- "Tomorrow I plan to learn about textual analysis."
z <- "The day after I will take a break and drink a beer."
cat(x, y, z, fill = 1) # the fill option specifies line width

# Substituting strings and numbers

x <- "The R package is great"
sprintf("You know what? %s", x)
y <- 5
sprintf("You know what? I had %d beers last night", y)
sprintf("Here are some digits from Pi: %f", pi)

# Counting string elements and characters
length("How many elements are in this string?")
length(c("How", "many", "elements", "are", "in", "this", "string?"))
length(1:10)

nchar("How many characters are in this string?")
nchar(c("How", "many", "characters", "are", "in", "this", "string?"))
# counting elements and characters becomes very useful when constructing with loops etc

# Special characters

string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
string3 <- "\""
string4 <- "\'" # if we want to include a single or double quote in our string we use the backslash (\) to escape the character
TASK: include a backslash in a string.

x <- c("\"", "\\")
x
writeLines(x) # beware that the printed representation of a string is different from the contents of the string itself


# String manipulation with stringr

# We can perform a lot of the core string manipulation tasks (e.g. removing whitespace, converting to lowercase etc)
# using base R functions. However we will use a package that simplifies the syntax: stringr

help("stringr")

# All functions in stringr start with str_ and take a vector of strings as the first argument
x <- "Hello, this is a bog standard string."
str_length(x)
str_c(x, " ", "Not very interesting at all.") # combine strings
str_sub(x, 1, 10) 
# QUESTION: what is the str_sub function doing to the string?

y <- c("Hello", "This", "is a bog standard", "string")
str_subset(y, "[aeiou]") # returns strings matching the pattern i.e. contain a vowel
str_subset(y, "[qrstuvwxyz]")

# Change text to upper, lower or title case
uc <- "DOWN WITH THAT SORT OF THING"
lc <- "careful now"
str_to_upper(lc)
str_to_lower(uc)
str_to_title(uc) 

# String matching
str_detect(y, "[aeiou]") # tells you if there’s any match to the pattern
str_count(y, "[aeiou]") # counts how many vowels are in each string
str_locate(y, "[aeiou]") # gives the position of the first match
str_extract(y, "[aeiou]") # extracts the text of the first match
str_match(y, "(.)[aeiou](.)") # extract the characters on either side of the vowel
str_replace(y, "[aeiou]", "?") # replace first match with a specified character
str_split(x, "") # split a string into individual characters based on a specified separator
str_dup(x, times = 10) # duplicates the string n times

# Removing leading and trailing whitespace
text <- c("Text ", " with", " whitespace ", " on", "both ", " sides ")
print(text)
# remove whitespaces on both sides
str_trim(text, side = "both") # other options include "right" and "left"
str_pad("beer", width = 10, side = "left") # add whitespace on the left of the string

# Set operations for strings
set_1 <- c("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c("sierra", "bells", "harpoon", "lagunitas", "founders")
union(set_1, set_2) # list all individual elements from the sets
intersect(set_1, set_2) # list all common elements from the sets
setdiff(set_1, set_2) # returns elements in set_1 not in set_2; swap order of sets

# To test if two vectors contain the same elements regardless of order use setequal():
set_3 <- c("woody", "buzz", "rex")
set_4 <- c("woody", "andy", "buzz")
set_5 <- c("andy", "buzz", "woody")
setequal(set_3, set_4)

set_6 <- c("woody", "andy", "buzz")
identical(set_4, set_6) # check if sets are exactly equal (elements and order)

# Identifying if element is in string
good <- "andy"
bad <- "sid"
is.element(good, set_5) # is the word "andy" in set_5?
good %in% set_5 # same as above
# TASK: see if the word "sid" is in set_3.

# Sort a string
sort(set_5)
sort(set_5, decreasing = TRUE)


# Categorical Variables #

# Known as factor variables in R (and other packages like Stata etc), 
# they group observations into exhaustive and mutually exclusive categories.
# We'll use the forcats package to work with categorical variables in R:
library(forcats) # not part of the core tidyverse package so we need to load it in separately

# Create a factor
x <- c("male", "female", "female", "male", "female") # list of observations for biological sex
sex <- factor(x)
sex
# QUESTION: how many observations and levels are there for this factor variable?

class(sex) # confirm it is a factor variable
unclass(sex) # show the underlying values of this variable: female = 1, male = 2 (numeric values are added alphabetically by default);
# we can change this by specifying the "levels" option:
sex2 <- factor(x, levels = c("male", "female"))
levels(sex2)  # display the levels (i.e. categories) of this variable
summary(sex2) # summarise the variable i.e. frequency count

# We can convert an existing list of strings to a factor variable:
group <- c("Group1", "Group2", "Group2", "Group1", "Group1")
group2 <- as.factor(group)
levels(group2)

# Instead of numbering categories alphabetically, we can do so according to when a factor first appears:
las <- c("Glasgow", "Edinburgh", "Aberdeen", "Glasgow", "Orkney", "Edinburgh")
cat_las <- factor(las, unique(las))
attributes(cat_las)
unclass(cat_las)

# Ordering factor variables
ses <- c("low", "middle", "low", "low", "low", "low", "middle", "low", "middle",
         "middle", "middle", "middle", "middle", "high", "high", "low", "middle",
         "middle", "low", "high")
ses <- factor(ses, levels = c("low", "middle", "high"), ordered = TRUE)
print(ses) # categories are ordered from "low" to "high"
factor(ses, levels = rev(levels(ses))) # you can also reverse the order of levels if desired

# Recoding categorical variables
# The "plyr" package is useful for this task
new_ses <- plyr::revalue(ses, c("low" = "small", "middle" = "medium", "high" = "large"))
print(new_ses)
levels(new_ses)
# Note that using the :: notation allows you to access the revalue() function without having to fully
# load the plyr package

# Dropping categories with no observations
ses_2 <- ses[ses != "middle"] # create a new variable where ses does not equal the value "middle"
summary(ses_2)
droplevels(ses_2)

# Dealing with Dates #

# Dates are represented by the Date class and times are represented by the POSIXct or the POSIXlt class. 
# Dates are stored internally as the number of days since 1970-01-01 while times are stored internally as the number of seconds 
# since 1970-01-01.

# System properties

Sys.timezone() 
Sys.Date()
Sys.time()

# Converting strings to dates
# This is an important process as dates are often imported in R and other software packages
# as strings.
x <- "2015-07-01" # string in YYYY-MM-DD format
z <- as.Date(x)
class(z)
class(x)

y <- "07/01/2015" # string in MM/DD/YYYY format
z <- as.Date(y, format = "%m/%d/%Y") # specify format of date
class(z)
class(y)
# Now that the information is in date format we can perform calculations involving units of time

# While we've used the base R functions to work with dates so far, we are better off
# using a dedicated package for working with this data type: "lubridate"
# Most of the material in this section is derived from: https://data.library.virginia.edu/working-with-dates-and-time-in-r-using-the-lubridate-package/

library(lubridate)
?lubridate # comes as part of the "tidyverse" collection of data science packages

begin <- c("May 11, 1996", "September 12, 2001", "July 1, 1988")
end <- c("7/8/97","10/23/02","1/4/91") # sample observations for the start and end date of a process
class(begin)
class(end)

(begin <- mdy(begin)) # convert to date, replacing the original object
(end <- mdy(end)) # convert to date, replacing the original object
class(begin)
class(end)

# The “Date” class means dates are stored as the number of days since January 1, 1970, 
# with negative values for earlier dates. 
# We can use the as.numeric function to view the raw values:
as.numeric(begin)
as.numeric(end)

# We can also use "lubridate" for handling dates with hours, minutes and seconds:
begin <- c("May 11, 1996 12:05", "September 12, 2001 1:00", "July 1, 1988 3:32")
begin <- mdy_hm(begin)
class(begin) # the dates are now interpeted as the number of seconds since January 1, 1970
print(begin)

"lubridate provides three classes, or three different ways, to distinguish between different types of time spans.
1. Duration
2. Interval
3. Period

Understanding these classes will help you get the most out of lubridate.

The most simple is Duration. This is simply a span of time measured in seconds. There is no start date.

An Interval is also measured in seconds but has an associated start date. An Interval measures elapsed seconds between two specific points in time.

A Period records a time span in units larger than seconds, such as years or months. 
Unlike seconds, years and months differ in time. June has 30 days while July has 31 days. 
February has 28 days except for leap years when it has 29 days. 
With the Period class, we can add 1 month to February 1 and get March 1. 
It allows us to perform calculations in calendar or clock time as opposed to absolute number of seconds." (Ford, 2017: https://data.library.virginia.edu/working-with-dates-and-time-in-r-using-the-lubridate-package/)

start <- mdy_hm("2-11-2019 5:21")
end <- mdy_hm("2-12-2019 5:21")
# Calculate interval between these dates
time_interval <- start %--% end # the "%--%" operator calculates the interval between two date objects
print(time_interval)
print(str(time_interval)) # examine the structure of the object

time_duration <- as.duration(time_interval)
print(time_duration) # displays number of seconds in the interval

time_period <- as.period(time_interval)
print(time_period)
str(time_period)

# We can also use lubridate to extract certain properties of a date object e.g. the year or month
x <- c("2015-07-01", "2015-08-01", "2015-09-01")
year(x)
month(x)
day(x) # day of the month
wday(x) # day of the week
wday(x, label = TRUE, abbr = FALSE) # day of the week with label

# We can alter the values in a date object:
# update(x, year = c(2013, 2014, 2015), month = 9)
# print(x) # NOT WORKING

# Lubridate makes it easy to create sequences of dates:
sampyears <- seq(ymd("2010-1-1"), ymd("2015-1-1"), by = "years")
print(sampyears)
sampyears <- seq(ymd("2010-1-1"), ymd("2015-1-1"), by = "months")
print(sampyears)

# Calculations with dates
# "Since R stores date and time objects as numbers, this allows you to perform various calculations
# such as logical comparisons, addition, subtraction, and working with durations." (Boehmke, 2016: 71)
x <- Sys.Date()
x

y <- as.Date("2015-09-11")
x > y
x - y
# TASK: describe the results produced by the above block of code.

y + days(4)
OlsonNames() # lists time zones

# <- is the assignment operator (= in Stata, Python and other languages). You can use
# = to assign values to objects but it is not standard practice (and reserved for argument association).

# Note that R is a case sensitive programming language. Meaning all variables, functions, and
# objects must be called by their exact spelling:

x # y
x # Y

a <- c(1, 2, 3, 4, 5) # vector (i.e. a list or array)
b <- c(6, 7, 8, 9, 10)
c <- c(1, 2, 3)

a + b # adds each element of the vectors together in order (i.e. 1 + 6, 2 + 7 etc)
# This is known as vectorization and is a very useful function in R.
a # b
a + c # generates a warning that the vectors are not multiples of each other (i.e. one has 5 elements, the other 4)
# When vectors are of unequal lenght, the shorter vector is "recycled" i.e. goes back to the start.



##########################################################################################

##########################            Preliminaries              #########################

##########################################################################################

# We suggest that you make a copy of this file imediately!
# 
# 
# ##############################################
# # IT IS IMPORTANT THAT YOU READ THIS HANDOUT #
# # AND FOLLOW THE R FILE LINE BY LINE! #
# ##############################################
# 
# 
# The file is sequential. 
# 
# It MUST be run line by line. 
# 
# Many of the commands will NOT run if earlier lines of commands have not been 
# executed.
# 
# 
# Anotate your new copy of the file as you work through it with your own notes 
# (use "#" to comment out your notes).
# 
# There are "Questions" for you to answer and "Tasks" for you to do.
# 
# 
# Useful Websites:
# - https://jakevdp.github.io/PythonDataScienceHandbook/
# 
# 
# 
# Cheat Sheets:

##########################################################

# System Setup #

# Create a R project folder/directory #

# Open RStudio and follow these instructions:
# 	- File > New Project
#	- Create project directory

getwd() # tells us the current working directory i.e. workspace
# setwd("C:/Users/mcdonndz-local/Desktop/temp") # set the working directory to a specified directory; however we have no need to
# do this as we have already set up a directory to store all of the components of our R project.

folders = c('data_raw', 'data_clean', 'temp', 'logs') # create a list with folder names
for(f in folders) {
  print(f)
  dir.create(f)
}

dir() # list all files in a directory
head(dir(recursive = TRUE)) # list all files in a directory (including its subdirectories); head() restricts the output to the first few results

dir(pattern = "\\.csv$", recursive = TRUE) # find all files that end in ".csv"
# The above command used regular expressions to detect patterns in text.

# Delete the folders
unlink(recursive = TRUE) # NOT WORKING!!!

# TASK: create the folders once more

# Save a file in the 'temp' folder:
data <- file.create("./data_raw/sampdata.csv")
write.csv(data, "./data_clean/sampdata_20190321.csv")
# Note the use of "." at the beginning of the file path; this signifies that the current working directory
# should form the first part of the path without needing to be explicitly stated. This is an example of
# using relative file paths and is considered good practice.

# List all files in our working directory
list.files() # lists the folders at the root of our working directory
list.files(recursive = TRUE) # lists the files within the folders in our working directory
list.files(pattern = ".csv", recursive = TRUE) # only list files that match a given pattern

file.info("./data_raw/sampdata.csv") # displays some basic file information 
# (e.g. size, whether it is a folder, created and modified times)

# Remove all files in our working directory
unlink(list.files(recursive = TRUE))

# That's enough file management for now. There are lots of other tasks we can perform, such as copying, moving,
# opening, checking if a file exists etc, that we do not cover here: see [http://theautomatic.net/2018/07/11/manipulate-files-r/]

# We've introduced two important practices in the previous code:
# 	- loops
# 	- exception handling
# 
# We'll spend some time later on in the workshop explaining these in detail but feel free to write some
# comments documenting what you think is happening in the code.


# Environment Objects #

# We can remove some of the objects we've created (i.e. delete variables):
ls() # list created objects
rm("a") # delete the object "a"
exists("x") # check if the object "x" exists
rm(c("x", "y")) # you can remove multiple objects by using the `c()` function

help("c") # very useful function: combines values into a vector or list

history(Inf) # displays all of the commands executed in this R session


# Workspace Options #

help(options)
options() # wide range of options for displaying results etc
options(digits=3) # change a specific option (i.e. number of digits to print on output)


# Saving Files #

save.image(file = "temp.RData") # saves the entire workspace to the current directory i.e. all of the objects we've created


# Installing Packages #

installed.packages() # check which packages are already installed
install.package("haven") # installs the user-written package haven, which provides functionality for working with data sets from other
# statistical software packages (e.g. SPSS, Stata, SAS).

library(haven) # load in the haven package 
?haven # examine the help files for this package

install.packages("tidyverse") # the tidyverse is a curated set of packages that are particularly useful for data science/analytics.
library(tidyverse)
?tidyverse

.libPaths() # displays where packages are installed


# Writing Documents Using R Markdown #
# A R Markdown file weaves R code and output with narrative text to produce a publication (e.g. Word document, webpage, book).
install.packages("rmarkdown")
library(rmarkdown)
?rmarkdown

