# Managing Data Structures in R #
# Boehmke, 2016

# Proficiency in marshalling data structures for the purpose of analysis is a 
# (some would say "the") crucial data science skill in industry and academia.

# Data structures come in many forms: vectors, lists, matrices and data frames to name a few.
# You can think of them as datasets of different dimensions (e.g. rows and columns) and
# data types (e.g. numbers, dates, strings etc).

# Data Structure Basics
vector <- 1:10
list <- list(item1 = 1:10, item2 = LETTERS[1:10])
matrix <- matrix(1:12, nrow = 4)
df <- data.frame(item1 = 1:10, item2 = LETTERS[1:10])

str(vector)
str(list)
str(matrix)
str(df)
# TASK: describe the structure of each of these objects.

# R objects have attributes, which can be thought of as metadata describing the object e.g. variable names, object class etc.
attributes(df) # displays the three attributes of our dataframe object.
names(df)
length(df) # returns number of columns
length(vector) # returns number of elements or items in a list

# In this session we focus on managing data frames, though we encourage you to consult
# Boehmke's' (2016) "Managing Data Structures in R" chapter for guidance on handling
# vectors, lists and matrices.

# Data frames are usually imported into R using the read.table() or read.csv() - and their variants - functions.
# However we can also create our own data frames using data.frame(); this comes in handy
# not only for teaching purposes but also for simulation and exploration purposes.

df <- data.frame(col1 = 1:3,
                 col2 = c("this", "is", "text"),
                 col3 = c(TRUE, FALSE, TRUE),
                 col4 = c(2.5, 4.2, pi))
# TASK: describe the structure of this data frame. Hint: use "str(df)".
nrow(df)
ncol(df)

# Note how col2 in df was converted to a column of factors by default i.e. categorical variable.
# If we want to store the strings as characters and not factors then we need to specify
# the stringsAsFactors = FALSE option.
df <- data.frame(col1 = 1:3,
                 col2 = c("this", "is", "text"),
                 col3 = c(TRUE, FALSE, TRUE),
                 col4 = c(2.5, 4.2, pi), stringsAsFactors = FALSE)
str(df)

# Convert existing objects into a data frame
v1 <- 1:3
v2 <-c("this", "is", "text")
v3 <- c(TRUE, FALSE, TRUE)
# convert same length vectors to a data frame using data.frame()
data.frame(col1 = v1, col2 = v2, col3 = v3)

# Adding columns

v4 <- c("A", "B", "C")
cbind(df, v4) # adds a new column to our existing data frame

# Adding rows

# This is complicated by the fact that the values of the new row must be the same class
# as the values in the existing rows e.g. if column 1 is an integer, then this value in 
# the new row must also be an integer. Otherwise the entire data frame is converted to a
# different class.

adding_df <- data.frame(col1 = 4, col2 = "R", col3 = FALSE, col4 = 1.1, stringsAsFactors = FALSE)
df2 <- rbind(df, adding_df)
str(df2)
# TASK: describe what the above code has achieved. Try altering the values of the new row
# and appending it to the data frame; what happens?

# There are better ways to join data frames together than to use cbind() and rbind() but
# they are useful techniques to know.

# Adding attributes

str(df)
dim(df) # three rows, four columns
attributes(df)

# Let's add row names to the dataset
rownames(df) <- c("Unit 1", "Unit 2", "Unit 3")
df

# Now let's alter the column names
colnames(df) <- c("Variable 1", "Variable 2", "Variable 3", "Variable 4")
df

# We can also add a label or comment to the dataset:
comment(df) <- "This dataset contains sample data from the 2019 R workshop"
attributes(df)
# TASK: try adding a second comment to the dataset; what happens?

# Subsetting a data frame

# Sometimes we are only interested in viewing or working with a subset of rows or columns in our data.
df
df[1:2] # displays the first two columns
df[1:2,] # displays the first two rows
df[1:2, 1:2] # displays the first two rows and columns
df[1:2, c("Variable 1", "Variable 2")] # same as above, this time specifying column names
# Note how an index begins at 1 in R, in comparison to Python where it begins at 0.
# We index data frames, tibbles, and other arrays by row first, and then by column. Arrays may also have more than two dimensions.

relcols <- c("Variable 1", "Variable 3")
df[, relcols]
# TASK: describe what the above code is doing.


# Dealing with Missing Values #

# In R, missing values are often represented by NA or some other user-specified value (e.g. 99).
# Missing values are problematic as any the result of any operation involving them will also be missing (unknown). For example:
x <- NA
y <- NA
x + 10
y - 500
NA == NA

# Identifying missing values
x <- c(1:4, NA, 6:7, NA) # vector with missing data
x
is.na(x) # identify which elements of the vector are missing
which(is.na(x)) # identify where in the vector the missing values are
sum(is.na(x)) # count the number of missing values

# data frame with missing values
df <- data.frame(col1 = c(1:3, NA),
                 col2 = c("this", NA,"is", "text"),
                 col3 = c(TRUE, FALSE, TRUE, TRUE),
                 col4 = c(2.5, 4.2, 3.2, NA),
                 stringsAsFactors = FALSE)
is.na(df)
is.na(df$col4) # identify missing values in a specific column
sum(is.na(df))

# Recoding missing values
x[is.na(x)] <- mean(x, na.rm = TRUE) # recode missing values with the mean
round(x, 2)
# Note how we only operated on the missing values of x by using the subsetting operator
# i.e. []. The "na.rm = TRUE" option ensures we only calculate the mean for non-missing observations.

df <- data.frame(col1 = c(1:3, 99), col2 = c(2.5, 4.2, 99, 3.2)) # data frame that codes missing values as 99
df[df == 99] <- NA
df

# Excluding missing values
x <- c(1:4, NA, 6:7, NA)
mean(x)
# QUESTION: why is the mean() function not returning a numeric value?
mean(x, na.rm = TRUE)

df
mean(df[, "col2"])
mean(df[, "col2"], na.rm = TRUE)

# We can also use the complete.cases() function to identify and exclude rows with missing values
complete.cases(df) # rows three and four have missing values for some/all of their variables
df[complete.cases(df), ] # list non-missing rows
df[!complete.cases(df), ] # list missing rows
na.omit(df) # list non-missing rows



# Exporting Data #

# In this section we focus on exporting datasets as text, Excel and R files.
# We will use a mix of base R and specific packages i.e. readr, xlsx

# Exporting as a csv file

auto <- read_csv("C:/Users/mcdonndz-local/Desktop/github/aqmen_wp3/data/auto.csv") # read in the data set
str(auto)
auto

write_csv(auto, "./data_clean/auto2.csv")
# write_csv() has two useful properties:
#	- it encodes strings in UTF-8
#	- it encodes dates as ISO8601
# Both of these mean that the resulting file can be easily parsed by other languages/programs.

# Exporting as a xlsx file

auto <- read_excel("C:/Users/mcdonndz-local/Desktop/github/aqmen_wp3/data/auto.xlsx") # read in the data set
str(auto)
auto

library(readxl)
write_xlsx(auto, file = "./data_clean/auto2.xlsx")

# Exporting to rds files

auto <- read_excel("C:/Users/mcdonndz-local/Desktop/github/aqmen_wp3/data/auto.xlsx") # read in the data set
str(auto)
auto

save(auto, "./data_clean/auto2.rds")


